.. _vibr-implementation:

Программная реализация
======================

Функция-решатель (Солвер)
-------------------------

Алгоритм построенный в предыдущем разделе легко записать как
функцию Python, вычисляющую :math:`y^0, y^1, \ldots, y^{N}` по
заданным входным параметрам :math:`U, \omega, \tau` и :math:`T`:

.. literalinclude:: codes/vib_undamped.py
   :lines: 3-21
				
Также будет удобно реализовать функцию для построения графиков точного
и приближенного решений:

.. literalinclude:: codes/vib_undamped.py
   :lines: 23-39

Соответствующая основная программа вызывающая эти функции для
моделирования заданного числа периодов (``num_periods``) может иметь
вид

.. code-block:: python

   U = 1
   omega = 2*pi
   tau = 0.05
   num_periods = 5
   P = 2*np.pi/tau    #  один период
   T = P*num_periods
   u, t = solver(U, omega, tau, T)
   visualize(u, t, U, omega, tau)


.. index:: ArgumentParser

Задание некоторых входных параметров удобно осуществлять через
командную строку. Ниже представлен фрагмент кода, использующий
инструмент ``ArgumentParser`` из модуля ``argparse`` для определения 
пар "параметр значение" (``--option value``) в командной строке:

.. code-block:: python

   import argparse
   parser = argparse.ArgumentParser()
   parser.add_argument('--U', type=float, default=1.0)
   parser.add_argument('--omega', type=float, default=2*np.pi)
   parser.add_argument('--tau', type=float, default=0.05)
   parser.add_argument('--num_periods', type=int, default=5)
   a = parser.parse_args()
   U, omega, tau, num_periods = a.U, a.omega, a.tau, a.num_periods

Стандартный вызов основной программы выглядит следующим образом:

.. code-block:: text

   Terminal> python vib_undamped.py --num_periods 20 --tau 0.1

Вычисление производной :math:`u'(t)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В приложениях часто необходимо анализировать поведение скорости
:math:`u'(t)`. Приближенно найти ее по полученным в 
узлах сетки :math:`\omega_\tau` значениям :math:`y` можно, например,
используя центральную разностную производную:

.. math::
   u'(t_n) \approx v^n = \frac{y^{n+1} - y^n}{2\tau} =
   y_{\mathring{t}}^n.
   :label: verb:appr:vel

Эта формула используется во внутренних узлах сетки :math:`\omega_\tau`
при :math:`n = 1, 2, \ldots, N-1`. Для :math:`n = 0` скорость
:math:`v^0` задана начальным условием, а для :math:`n = N` мы можем
использовать направленную (левую) разностную производную :math:`v^N =
y_{\bar{t}}^N`.

Для вычисления производной можно использовать следующий (скалярный)
код:

.. code-block:: python

   v = np.zeros_like(u)  # or v = np.zeros(len(u))
   # Используем центральную разностную производную во внутренних узлах
   for i in range(1, len(u)-1):
	v[i] = (u[i+1] - u[i-1])/(2*tau)
   # Используем начальное условие для u'(0)
   v[0] = 0
   # Используем левую разностную производную
   v[-1] = (u[-1] - u[-2])/tau

Мы можем избавиться от цикла (медленного для больших :math:`N`),
векторизовав вычисление разностной производной. Фрагмент кода,
приведенного выше, можно заменить следующей векторизованной формой:

.. code-block:: python

   v = np.zeros_like(u)
   v[1:-1] = (u[2:] - u[:-2])/(2*tau)  # центральная разностная производная
   v[0] = 0                            # начальное условие u'(0)
   v[-1] = (u[-1] - u[-2])/tau         # левая разностная производная


Верификация реализации алгоритма
--------------------------------

Вычисления в ручную
~~~~~~~~~~~~~~~~~~~

Простейший способ проверки правильности реализации алгоритма
заключается в вычислении значений :math:`y^1, y^2` и :math:`y^3`,
например с помощью калькулятора и в написании функции, сравнивающей
эти результаты с соответствующими результатами вычисленными с помощью
функции ``solver``. Представленная ниже функция ``test_three_steps``
демонстрирует, как можно использовать "ручные" вычисления для
тестирования кода:

.. literalinclude:: codes/vib_undamped.py
   :pyobject: test_three_steps

Тестирование на простейших решениях
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Построение тестовой задачи, решением которой является постоянная
величина или линейная функция, помогает выполнять начальную отладку и
проверку реализации алгоритма, так как соответствующие вычислительные
алгоритмы воспроизводят такие решения с машинной точностью. Например,
методы второго порядка точности часто являются точными на полиномах
второй степени. Возьмем точное значение второй разностной производной
:math:`(t^2)_{\bar{t}t}^n = 2`. Решение :math:`u(t) = t^2` дает
:math:`u'' + \omega^2 u = 2 + (\omega t)^2 \ne 0`. Следовательно,
необходимо добавить функцию источника в уравнение:
:math:`u'' + \omega^2 u = f`. Такое уравнение имеет решение
:math:`u(t) = t^2` при :math:`f(t) = (\omega t)^2`. Простой
подстановкой убеждаемся, что сеточная функция :math:`y^n = t_n^2`
является решением разностной схемы. Выполните
:ref:`задачу 1 <Problem-linear-quadratic-verification>`.

Анализ скорости сходимости
~~~~~~~~~~~~~~~~~~~~~~~~~~

.. index:: Скорость сходимости

Естественно ожидать, что погрешность метода :math:`\varepsilon` должна
уменьшаться с уменьшением шага :math:`\tau`. Многие вычислительные
методы (в том числе и конечно-разностные) имеют степенную зависимость
погрешности :math:`\varepsilon` от :math:`\tau`:

.. math::
   \varepsilon = M \tau^r,
   :label: vib:conv:rate

где :math:`C` и :math:`r` --- постоянные (обычно неизвестные), не
зависящие от :math:`\tau`. Формула :eq:`vib:conv:rate` является
асимптотическим законом, верным при достаточно малом параметре
:math:`\tau`. Насколько малом оценить сложно без численной оценки
параметра :math:`r`.

Параметр :math:`r` называется *скоростью сходимости*.

Оценка скорости сходимости
++++++++++++++++++++++++++

Чтобы оценить скорость сходимости для рассматриваемой задачи, нужно
выполнить

* провести :math:`m` расчетов, уменьшая на каждом из них шаг в два раза:
  :math:`\tau_k = 2^{-k}\tau_0`, :math:`k = 0, 1, \ldots, m-1`,
  
* вычислить :math:`L_2` -норму погрешности для каждого расчета
  :math:`\varepsilon_k = \sqrt{\sum_{n=0}^{N-1} (y^n -
  u_e(t_n)) \tau_k}`,
		
* оценить скорость сходимости на основе двух последовательных
  экспериментов :math:`(\tau_{k-1}, \varepsilon_{k-1})` и  :math:`(\tau_{k},
  \varepsilon_{k})`, в предположении, что погрешность подчинена закону
  :eq:`vib:conv:rate`. Разделив :math:`\varepsilon_{k-1} = M\tau_{k-1}^r`
  на :math:`\varepsilon_{k} = M\tau_{k}^r` и решая получившееся
  уравнение относительно :math:`r`, получим

  .. math::
	 r_{k-1} =
	 \frac{\ln(\varepsilon_{k-1}/\varepsilon_k)}{\ln(\tau_{k-1}/\tau_k)},
	 \quad k = 0, 1, \ldots, m-1.

Будем надеяться, что полученные значения :math:`r_0, r_1, \ldots,  r_{m-2}`
сходятся к некоторому числу (в нашем случае к 2).

Программная реализация
++++++++++++++++++++++

Ниже приведена функция для вычисления последовательности :math:`r_0,
r_1, \ldots, r_{m-2}`.

.. literalinclude:: codes/vib_undamped.py
   :pyobject: convergence_rates

Ожидаемая скорость сходимости --- 2, так как мы используем
конечно-разностную аппроксимации второго порядка для второй
производной в уравнении и для первого начального
условия. Теоретический анализ погрешности аппроксимации дает
:math:`r=2`.

Для рассматриваемой задачи, когда :math:`\tau_0` соответствует 30
временным шагам на период, возвращаемый список ``r`` содержит элементы
равные ``2.00``. Это означает, что все значения :math:`\tau_k`
удовлетворяют ассимтотическому режиму, при котором выполнено
соотношение :eq:`vib:conv:rate`.

Теперь мы можем написать тестовую функцию, которая вычисляет скорости
сходимости и проверяет, что последняя оценка достаточно близка
к 2. Здесь достаточна граница допуска 0.1.

.. literalinclude:: codes/vib_undamped.py
   :pyobject: test_convergence_rates

Безразмерная модель
~~~~~~~~~~~~~~~~~~~

При моделировании полезно использовать безразмерные переменные, так
как в этом случае нужно задавать меньше параметров. Рассматриваемая
нами задача обезразмеривается заданием переменных :math:`\bar{t} =
t/t_c` и :math:`\bar{u} = u/u_c`, где :math:`t_c` и :math:`u_c`
характерные масштабы для :math:`t` и :math:`u`,
соответственно. Задача для ОДУ принимает вид

.. math::
   \frac{u_c}{t_c} \frac{d^2 \bar{u}}{d \bar{t}^2} + u_c \bar{u} = 0,
   \quad u_c \bar{u}(0) = U, \quad  \frac{u_c}{t_c} \frac{d \bar{u}}{d
   \bar{t}}(0) = 0.

Обычно в качестве :math:`t_c` выбирается один период колебаний,
т.е. :math:`t_c = 2\pi/\omega` и :math:`u_c = U`. Отсюда получаем
безразмерную модель

.. math::
   \frac{d^2 \bar{u}}{d \bar{t}^2} + 4\pi^2 \bar{u} = 0, \quad
   \bar{u}(0) = 1, \quad \bar{u}'(0) = 0.
   :label: vib:scaled

Заметьте, что в :eq:`vib:scaled` отсутствуют физические
параметры. Таким образом мы можем выполнить одно вычисление
:math:`\bar{u}(\bar{t})` и затем восстановить любое :math:`u(t; \omega,U)`
следующим образом

.. math::
   u(t; \omega, U) = u_c \bar{u}(t/t_c) = U \bar{u}(\omega t/(2\pi)).

Расчет для безразмерной модели можно выполнить вызвав функцию
``solver(U = 1, omega = 2*np.pi, tau, T)``. В этом случае период равен
1 и ``T`` задает количество периодов. Выбор ``tau = 1./N`` дает
:math:`N` шагов на период.

