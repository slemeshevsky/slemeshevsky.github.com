Колебательные процессы описываются дифференциальными уравнениями,
решения которых представляют собой изменяющуюся со временем
синусоиду. Такие решения предъявляют некоторые дополнительные (по
сравнению с монотонными и очень гладкими решениями) требования к 
вычислительному алгоритму. Как частота, так и амплитуда колебаний
должны достаточно точно воспроизводится численным методом
решения. Большинство представленных в данном разделе подходов могут
использоваться для построения численных методов решения уравнений в
частных производных с решениями колебательного типа в многомерном
случае.

.. _vibr-fdd:

Конечно-разностная дискретизация
==================================

Многие вычислительные проблемы, возникающие при вычислении
осциллирующих решений обыкновенных дифференциальных уравнений и
уравнений в частных производных могут быть проиллюстрированы на
простейшем ОДУ второго порядка :math:`u'' + u = 0`.

Базовая модель колебательного процесса
---------------------------------------

Колебательная система без затуханий и внешних сил может быть описана
начальной задачей для ОДУ второго порядка

.. index:: Уравнение вибрации
.. math::
   u'' + \omega^2 u = 0, \quad t \in (0, T],
   :label: vibr

.. math::
   u(0) = U,\quad  u'(0) = 0.
   :label: vibr:init

Здесь :math:`\omega` и :math:`U` --- заданные постоянные. Точное
решение задачи :eq:`vibr` -- :eq:`vibr:init` имеет вид

.. math::
   u(t) = U\cos{\omega t},
   :label: vibr:sol

т.е. :math:`u` описывает колебания с постоянной амплитудой :math:`U` и
угловой частотой :math:`\omega`. Соответствующий период колебаний равен
:math:`P = 2\pi/\omega`. Число периодов в секунду --- это
:math:`f = \omega/2\pi`. Оно измеряется в герцах (Гц). Как :math:`f`,
так и :math:`\omega` описываются частоту колебаний, но :math:`\omega`
более точно называется *угловой частотой* и измеряется в радиан/с.

В колебательных механических системах, описываемых задачей :eq:`vibr`
-- :eq:`vibr:init`  :math:`u` часто представляет собой координату или
смещение точки в системе. Производная :math:`u'(t)`, таким образом,
интерпретируется как скорость, а :math:`u''(t)` --- ускорение.  
Задача :eq:`vibr` -- :eq:`vibr:init` описывает не только механические
колебания, но и колебания в электрических цепях.


Разностная схема
----------------

При численном решении задачи :eq:`vibr` -- :eq:`vibr:init` будем
использовать равномерную сетку по переменной :math:`t` с шагом
:math:`\tau`:

.. math::
   \omega_\tau = \{ t_n = n\tau, \ n = 0, 1, \ldots N \}.

Приближенное решение задачи :eq:`vibr` -- :eq:`vibr:init` в точке
:math:`t_n` обозначим :math:`y^n`.

Простейшая разностная схема для приближенного решения задачи
:eq:`vibr` -- :eq:`vibr:init` есть

.. index:: Разностная схема

.. math::
   \frac{y^{n+1} - 2 y^{n} + y^{n-1}}{\tau^2} = -\omega^2 y^n.
   :label: vibr:efds

Кроме того необходимо аппроксимировать производную во втором начальном
условии. Будем аппроксимировать ее центральную разностную производную:

.. math::
   \frac{y^1 - y^{-1}}{2\tau} = 0.
   :label: vibr:efds:init

Для формулировки вычислительного алгоритма, предположим, что мы уже
знаем значение :math:`y^{n-1}` и :math:`y^{n}`. Тогда из
:eq:`vibr:efds` мы можем выразить неизвестное значение
:math:`y^{n+1}`:

.. math::
   y^{n+1} = 2y^n - y^{n-1} - \tau^2 \omega^2 y^n.
   :label: vibr:efds:rec

Вычислительный алгоритм заключается в последовательном применении
для :math:`n = 1, 2, \ldots`.

Очевидно, что :eq:`vibr:efds:rec` нельзя использовать при :math:`n =
0`, так как для вычисления :math:`y^1` необходимо знать неопределенное
значение :math:`y^{-1}` при :math:`t = -\tau`. Однако, из :eq:`vibr:efds:init`
имеем :math:`y^{-1} = y^{1}`. Подставляя последнее в
:eq:`vibr:efds:rec` при :math:`n=0`, получим

.. math::
   y^1 = 2 y^0 - y^1 - \tau^2 \omega^2 y^0,

откуда

.. math::
   y^1 = y^0 - \frac{1}{2} \tau^2\omega^2 y^0.
   :label: vibr:efds:init:1

В :ref:`упражнении 1 <Exercise-vibr-init-alt>` требуется использовать
альтернативный способ вывода :eq:`vibr:efds:init:1`, а также построить
аппроксимацию начального условия :math:`u'(0) = V \ne 0`.

Вычислительный алгоритм
-----------------------

Для решения задачи :eq:`vibr` -- :eq:`vibr:init` следует выполнить
следующие шаги:

1. :math:`y^0 = U`
2. вычисляем :math:`y^1`, используя :eq:`vibr:efds:init:1`
3. для :math:`n = 1, 2, \ldots,`
   
   1. вычисляем :math:`y^n`, используя :eq:`vibr:efds:rec` 

Более строго вычислительный алгоритм напишем на Python:

.. code-block:: python

   t = linspace(0, T, N+1)  # сетка по времени
   tau = t[1] - t[0]        # постоянный временной шаг
   u = zeros(N+1)           # решение
   
   u[0] = U
   u[1] = u[0] - 0.5*tau**2*omega**2*u[0]
   for n in range(1, N):
       u[n+1] = 2*u[n] - u[n-1] - tau**2*omega**2*u[n]

Безындексные обозначения
------------------------

.. index:: Разностная производная
.. index:: Разностная производная; левая
		   Разностная производная; правая

Разностную схему можно записать, используя безындексные
обозначения. Для *левой* и *правой разностных производных* соответственно
имеем 
   
.. math::
   y_{\bar{t}} \equiv \frac{y^{n} - y^{n-1}}{\tau}, \quad
   y_{t} \equiv \frac{y^{n+1} - y^{n}}{\tau}.


.. index:: Разностная производная; вторая

Для *второй разностной производной* получим

.. math::
   y_{\bar{t}t} = \frac{y_t - y_\bar{t}}{\tau} = \frac{y^{n+1} - 2y^{n} + y^{n-1}}{\tau^2}.

.. index:: Разностная производная; центральная
   
Для аппроксимации второго начального условия использовалась
*центральная разностная производная*:

.. math::
   y_{\mathring{t}} = \frac{y^{n+1} - y^{n-1}}{2\tau}
